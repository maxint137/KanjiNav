<!DOCTYPE html>

<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="icon" type="image/png" href="favicon.png" />

    <link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">


    <title>Kanji Navigator</title>
    <style>
        @import url(style.css);
        body {
            background-color: gray;
        }
        
        .text {
            /*http://jisho.org/search/%E5%8B%95%20%23kanji*/
            font-family: "HiraKakuPro-W3", "Hiragino Kaku Gothic Pro W3", "Hiragino Kaku Gothic Pro", "ヒラギノ角ゴ Pro W3", "メイリオ", Meiryo, "游ゴシック", YuGothic, "ＭＳ Ｐゴシック", "MS PGothic", "ＭＳ ゴシック", "MS Gothic", sans-serif;
            font-size: 22px;
            text-align: left;
            text-decoration: none;
            font-weight: normal;
            line-height: 1;
            text-anchor: middle;
        }
        
        .english {
            text-anchor: middle;
        }
        
        .background {
            stroke: white;
            stroke-width: 1px;
            fill: gray;
        }
        
        .node {
            background-color: white;
            /*stroke: #fff;
  stroke-width: 1.5px;*/
        }
        
        .spike {
            fill: url(#SpikeGradient);
            stroke-width: 0;
        }
    </style>
</head>


<body>
    <div class="col-xs-2" style="margin-bottom: 5px;">
        <input type="text" class="form-control input-sm" style="display: inline" id="word" placeholder="Enter a word here" value="楽しい">
    </div>
    <button type="button" class="btn btn-default btn-sm" onclick="navigateToWord()">Add</button>
    <button type="button" class="btn btn-default btn-sm" onclick="clearAll()">Clear</button>
    <script src="../extern/d3.v3.js"></script>
    <script src="../extern/jquery-1.10.2.min.js"></script>
    <script src="../extern/fullscreen.js"></script>
    <script src="../extern/cola.js"></script>
    <script src="kanjiNav.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

    <script>
        // the variables that manage everything, basically
        {
            // canvas size
            var width = 960,
                height = 500;

            var red = "rgb(125, 0, 0)";


            var nodeWidth = 30,
                nodeHeight = 35;

            // the object that communicates with the server to bring all the data
            var modelgraph = new kanjiNav.Graph(getParameterByName('JLPT'));

            // WebCola will render that graph, and we'll try to keep it updated with the modelgraph
            var viewgraph = {
                nodes: [],
                links: []
            };

            // the adapter
            var d3cola = cola.d3adaptor(d3)
                .linkDistance(80)
                .avoidOverlaps(true)
                //  computes ideal lengths on each link to make extra space around high-degree nodes, using 5 as the basic length.
                // Alternately, you can pass your own function f into linkDistance(f) that returns a specific length for each link (e.g. based on your data).
                //.symmetricDiffLinkLengths(15)
                .size([width, height]);

            // alternatively just use the D3 built-in force layout
            // var d3cola = d3.layout.force()
            //     .charge(-520)
            //     .linkDistance(80)
            //     .size([width, height]);

            // the D3 engine
            var outer = d3.select("body").append("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("pointer-events", "all");

            // UF why?
            var nodeMouseDown = false;
        }

        // add layers and zooming to the outer SVG
        {
            // https://github.com/d3/d3-3.x-api-reference/blob/master/Zoom-Behavior.md
            // Construct a new zoom behavior:
            var zoom = d3.behavior.zoom();
            outer.append('rect')
                .attr('class', 'background')
                .attr('width', "100%")
                .attr('height', "100%")
                // apply the behavior to selected element:
                .call(zoom.on("zoom", redraw))
                // enable the zoom behavior’s dblclick event listener
                .on("dblclick.zoom", zoomToFit);

            // the layers in play
            var vis = outer.append('g');
            var edgesLayer = vis.append("g");
            var nodesLayer = vis.append("g");

        }

        // define the gradients used down the road: SpikeGradient & (Reverse)EdgeGradient
        {
            var defs = outer.append("svg:defs");

            function addGradient(id, colour1, opacity1, colour2, opacity2) {
                var gradient = defs.append("svg:linearGradient")
                    .attr("id", id)
                    .attr("x1", "0%")
                    .attr("y1", "0%")
                    .attr("x2", "100%")
                    .attr("y2", "0%")
                    .attr("spreadMethod", "pad");

                gradient.append("svg:stop")
                    .attr("offset", "0%")
                    .attr("stop-color", colour1)
                    .attr("stop-opacity", opacity1);

                gradient.append("svg:stop")
                    .attr("offset", "100%")
                    .attr("stop-color", colour2)
                    .attr("stop-opacity", opacity2);
            }

            addGradient("SpikeGradient", "red", 1, "red", 0);
            addGradient("EdgeGradient", red, 1, "darkgray", 1);
            addGradient("ReverseEdgeGradient", "darkgray", 1, red, 1);
        }

        // adds a word to graph
        function main(word) {

            var d = modelgraph.getNode(kanjiNav.Word, word, addViewNode);
            $.when(d).then(function(startNode) {
                refocus(startNode);
            });
        }

        // adds the node to the viewgraph, picks the initial position based on the startpos and assignes viewgraphid
        // used to schedule the images rendering
        function addViewNode(v, startpos) {
            v.viewgraphid = viewgraph.nodes.length;

            if (typeof startpos !== 'undefined') {
                v.x = startpos.x;
                v.y = startpos.y;
            }

            viewgraph.nodes.push(v);

            // var d = v.getImage();
            // $.when(d).then(function(node) {

            //     d3.select("#" + node.name()).append("image")
            //         .attr("transform", "translate(2,2)")
            //         .attr("xlink:href", function(v) {
            //             var url = v.imgurl;
            //             var simg = this;
            //             var img = new Image();
            //             img.onload = function() {
            //                 simg.setAttribute("width", nodeWidth - 4);
            //                 simg.setAttribute("height", nodeHeight - 4);
            //             }
            //             return img.src = url;
            //         }).on("click", function() {
            //             click(node)
            //         })
            // });
        }

        // setup the transiation based on the move/zoom, as it comes from 
        function redraw(transition) {
            // if mouse down then we are dragging not panning
            if (nodeMouseDown) {
                debugger;
                return;
            }

            // read the current zoom translation vector and the current zoom scale
            (transition ? vis.transition() : vis)
            .attr("transform", "translate(" + zoom.translate() + ") scale(" + zoom.scale() + ")");
        }

        // expands the selected node, renders the updated graph
        function refocus(focus) {
            var neighboursExpanded = modelgraph.expandNeighbours(focus, function(v) {
                if (!inView(v))
                    addViewNode(v, focus);
            });

            // not sure why do we want to have it here in addition to the lines just below...
            refreshViewGraph();

            $.when(neighboursExpanded).then(function f() {
                refreshViewGraph();
            });
        }

        // sync the viewgraph with the modelgraph
        function refreshViewGraph() {
            // drop the links from the viewgraph first
            viewgraph.links = [];

            // set the color of each node in the viewgraph, based on the fully-expanded status
            viewgraph.nodes.forEach(function(v) {
                var fullyExpanded = modelgraph.fullyExpanded(v);
                v.colour = fullyExpanded ? "black" : red;
            });

            // create a link in the view for each edge in the model
            Object.keys(modelgraph.edges).forEach(function(e) {

                var l = modelgraph.edges[e];
                var u = modelgraph.nodes[l.source],
                    v = modelgraph.nodes[l.target];

                if (inView(u) && inView(v))
                    viewgraph.links.push({
                        source: u,
                        target: v
                    });

                // UF: not sure about these:
                if (inView(u) && !inView(v)) {
                    console.log("inView(u) && !inView(v)");
                    u.colour = red;
                }

                if (!inView(u) && inView(v)) {
                    console.log("!inView(u) && inView(v)");
                    v.colour = red;
                }
            });

            update();
        }

        // pushes the viewgraph data into the adapter and starts rendering process
        function update() {
            d3cola.nodes(viewgraph.nodes)
                .links(viewgraph.links)
                .start();

            var node = updateNodes(viewgraph);
            var link = updateLinks(viewgraph);

            d3cola.on("tick", function() {

                // setting the transform attribute to the array will result in syncronous calls to the callback provided for each node/link
                // so that these will move to the designated positions
                node.attr("transform", function(d) {
                    return "translate(" + (d.x - nodeWidth / 2) + "," + (d.y - nodeHeight / 2) + ")";
                });

                link.attr("transform", function(d) {
                        var dx = d.source.x - d.target.x,
                            dy = d.source.y - d.target.y;

                        var r = 180 * Math.atan2(dy, dx) / Math.PI;

                        return "translate(" + d.target.x + "," + d.target.y + ") rotate(" + r + ") ";
                    })
                    .attr("width", function(d) {
                        var dx = d.source.x - d.target.x,
                            dy = d.source.y - d.target.y;

                        return Math.sqrt(dx * dx + dy * dy);
                    });
            });
        }

        // re-populates edgesLayer with links
        function updateLinks(viewgraph) {
            // use the viewgrap's links to populate the edges-layer with objects based on the data:
            var link = edgesLayer.selectAll(".link")
                .data(viewgraph.links);

            // for every new entry insert a rect of class .link and initial height and position
            link.enter().append("rect")
                .attr("x", 0).attr("y", 0)
                .attr("height", 2)
                .attr("class", "link");

            // get rid of those which aren't listed anymore
            link.exit().remove();

            // update the fill of each of the elements, based on their state
            link
                .attr("fill", function(d) {
                    if (d.source.colour === red && d.target.colour === red) {
                        // UF never happens?
                        return red;
                    }

                    if (d.source.colour !== red && d.target.colour !== red) {
                        // the link between "resolved" nodes
                        return "darkgray";
                    }

                    return d.source.colour === red ? "url(#ReverseEdgeGradient)" : "url(#EdgeGradient)";
                });

            return link;
        }

        // re-populates the nodesLayer with nodes
        function updateNodes(viewgraph) {
            var node = nodesLayer.selectAll(".node")
                .data(viewgraph.nodes, function(d) {
                    return d.viewgraphid;
                })

            // erase the nodes which aren't here anymore
            node.exit().remove();

            // remember the last place/time the mouse/touch event has occured, so we can distinguish between a move and a click/tap
            var mouseDownEvent = {};
            var mouseUpEvent = {};
            var touchmoveEvent = 0;

            // insert a group that tracks the user interaction
            var nodeEnter = node.enter().append("g")
                .attr("id", function(d) {
                    return d.name()
                })
                .attr("class", "node")
                .on("mousedown", function() {
                    mouseDownEvent = d3.event;
                    nodeMouseDown = true;
                }) // recording the mousedown state allows us to differentiate dragging from panning
                .on("mouseup", function(e, x, y, z) {
                    mouseUpEvent = d3.event;
                    nodeMouseDown = false;
                })
                .on("touchmove", function() {
                    d3.event.preventDefault();
                    touchmoveEvent = d3.event.timeStamp;
                })
                .on("mouseenter", function(d) {
                    hintNeighbours(d)
                }) // on mouse over nodes we show "spikes" indicating there are hidden neighbours
                .on("mouseleave", function(d) {
                    unhintNeighbours(d)
                })
                .on("wheel", function(d) {
                    // UF: need to send that event to the canvas..
                    debugger;
                })
                .on("click", function(d) {
                    if (Math.abs(mouseDownEvent.screenX - mouseUpEvent.screenX) +
                        Math.abs(mouseDownEvent.screenY - mouseUpEvent.screenY) < 2) {
                        click(d);
                    }
                })
                .on("touchend", function(d) {
                    if (d3.event.timeStamp - touchmoveEvent < 100) {
                        click(d)
                    }
                })
                .call(d3cola.drag);

            nodeEnter.append("g")
                .attr("id", function(d) {
                    return d.name() + "_spikes"
                })
                .attr("transform", "translate(3,3)");

            // nodeEnter.append("rect")
            //     .attr("rx", 5).attr("ry", 5)
            //     .style("stroke-width", "0")
            //     .attr("width", nodeWidth).attr("height", nodeHeight)
            //     .on("click", function (d) { click(d) })
            //     .on("touchend", function (d) { click(d) });

            nodeEnter.append("text")
                .attr('class', 'text')
                .attr("dx", "0.7em")
                .attr("dy", "1.0em")
                .text(function(d) {
                    return d.id;
                });

            nodeEnter.append("text")
                .attr('class', 'furigana')
                .attr("dx", "-1.0em")
                .attr("dy", "0.0em")
                .text(function(d) {
                    return d.hiragana ? d.hiragana : '';
                });

            nodeEnter.append("text")
                .attr('class', 'english')
                .attr("dx", "1.5em")
                .attr("dy", "3.2em")
                .text(function(d) {
                    return d.english && 0 in d.english ? d.english[0] : '?';
                });

            nodeEnter.append("title")
                .text(function(d) {
                    return d.id;
                });

            node.style("fill", function(d) {
                return d.colour;
            });

            return node;
        }

        // animates the mouse-over hint
        function hintNeighbours(v) {
            if (!v.cast) return;
            var hiddenEdges = v.cast.length + 1 - v.degree;
            var r = 2 * Math.PI / hiddenEdges;
            for (var i = 0; i < hiddenEdges; ++i) {
                var w = nodeWidth - 6,
                    h = nodeHeight - 6,
                    x = w / 2 + 25 * Math.cos(r * i),
                    y = h / 2 + 30 * Math.sin(r * i),
                    rect = new cola.Rectangle(0, w, 0, h),
                    vi = rect.rayIntersection(x, y);
                var dview = d3.select("#" + v.name() + "_spikes");

                dview.append("rect")
                    .attr("class", "spike")
                    .attr("rx", 1).attr("ry", 1)
                    .attr("x", 0).attr("y", 0)
                    .attr("width", 10).attr("height", 2)
                    .attr("transform", "translate(" + vi.x + "," + vi.y + ") rotate(" + (360 * i / hiddenEdges) + ")")
                    .on("click", function() {
                        click(v)
                    });
            }
        }

        // stopping the hint
        function unhintNeighbours(v) {
            var dview = d3.select("#" + v.name() + "_spikes");
            dview.selectAll(".spike").remove();
        }

        // was the viewnode added?
        function inView(v) {
            return typeof v.viewgraphid !== 'undefined';
        }

        // handle the mouse-click, tap
        function click(node) {
            if (node.colour !== red)
                return;

            var focus = modelgraph.getNode(node.type, node.id);
            refocus(focus);
        }

        function graphBounds() {
            var x = Number.POSITIVE_INFINITY,
                X = Number.NEGATIVE_INFINITY,
                y = Number.POSITIVE_INFINITY,
                Y = Number.NEGATIVE_INFINITY;
            nodesLayer.selectAll(".node").each(function(v) {
                x = Math.min(x, v.x - nodeWidth / 2);
                X = Math.max(X, v.x + nodeWidth / 2);
                y = Math.min(y, v.y - nodeHeight / 2);
                Y = Math.max(Y, v.y + nodeHeight / 2);
            });
            return {
                x: x,
                X: X,
                y: y,
                Y: Y
            };
        }

        function clearAll() {

            viewgraph = {
                nodes: [],
                links: []
            };

            update();

            modelgraph.reset();
        }

        function navigateToWord() {

            main($("#word").val());
        }

        function fullScreenCancel() {
            outer.attr("width", width).attr("height", height);
            zoomToFit();
        }

        function zoomToFit() {
            var b = graphBounds();
            var w = b.X - b.x,
                h = b.Y - b.y;
            var cw = outer.attr("width"),
                ch = outer.attr("height");
            var s = Math.min(cw / w, ch / h);
            var tx = (-b.x * s + (cw / s - w) * s / 2),
                ty = (-b.y * s + (ch / s - h) * s / 2);
            zoom.translate([tx, ty]).scale(s);
            redraw(true);
        }

        function getParameterByName(name, url) {
            if (!url) {
                url = window.location.href;
            }
            name = name.replace(/[\[\]]/g, "\\$&");
            var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
                results = regex.exec(url);
            if (!results) return null;
            if (!results[2]) return '';
            return decodeURIComponent(results[2].replace(/\+/g, " "));
        }

        // get first node
        main(getParameterByName('start') || '楽しい');
    </script>
    <button onclick="fullScreen(outer[0][0], fullScreenCancel);zoomToFit()">Full screen</button>
    <button onclick="zoomToFit()">Zoom to fit (or double click)</button>

    <!-- Google analytics and the feedback stuff -->
    <script type="text/javascript">
        reformal_wdg_domain = "kanjiNav";
        reformal_wdg_mode = 0;
        reformal_wdg_title = "Kanji Navigator";
        reformal_wdg_ltitle = "Leave feedback";
        reformal_wdg_lfont = "";
        reformal_wdg_lsize = "";
        reformal_wdg_color = "#FFA000";
        reformal_wdg_bcolor = "#516683";
        reformal_wdg_tcolor = "#FFFFFF";
        reformal_wdg_align = "right";
        reformal_wdg_waction = 0;
        reformal_wdg_vcolor = "#9FCE54";
        reformal_wdg_cmline = "#E0E0E0";
        reformal_wdg_glcolor = "#105895";
        reformal_wdg_tbcolor = "#FFFFFF";

        reformal_wdg_bimage = "8489db229aa0a66ab6b80ebbe0bb26cd.png";
    </script>

    <script>
        (function(i, s, o, g, r, a, m) {
            i['GoogleAnalyticsObject'] = r;
            i[r] = i[r] || function() {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o),
                m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m)
        })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

        ga('create', 'UA-91206532-1', 'auto');
        ga('send', 'pageview');
    </script>

    <script type="text/javascript" language="JavaScript" src="http://idea.informer.com/tab6.js?domain=kanjiNav"></script>
    <noscript><a href="http://kanjiNav.idea.informer.com">Kanji Navigator feedback </a>
    <a href="http://idea.informer.com"><img src="http://widget.idea.informer.com/tmpl/images/widget_logo.jpg" /></a>
    </noscript>

</body>

</html>